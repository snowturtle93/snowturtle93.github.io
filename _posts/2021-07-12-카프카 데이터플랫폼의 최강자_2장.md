---
title: "카프카 데이터플랫폼의 최강자 2장"
author: Kang HyunGu
date: 2021-07-13 20:36:00 +0900
categories: [기술서적, 카프카데이터플랫폼의최강자]
tags: [기술서적]
toc: true
pin: true
comments: true
---
게임 데이터 실시간 처리를 위해 Kafka의 구조와 개발 방법을 익히기 위해 팀원과 스터디를 진행하기로해 앞으로 블로그에 책의 내용을 정리 요약하여 발표할 계획이다.
우선 2장은 카프카 설치에 관한 내용으로 간단히 진행해 보기로한다.
## 0.kafka의 간단한 구성도
<p align="center"><img src="{{site.url}}/img/posts/kafka_2/kafka_architecture.png" width="600" height="400"></p>
위의 그림처럼 Kafka는 Apache Zookeeper를 코디네이션 어플리케이션으로 사용하는데 Kafka를 설치하기전 Zookeeper에대해 간단히 알아보고 시작한다.

## 1. Kafka 관리를 위한 주키퍼
주키퍼는 본래 하둡의 서브 프로젝트중 하나였지만, 2011년 1월 부터 아파치 탑 레벨 프로젝트로 승격되었고 현재는 Kafka뿐만 아니라 Storm, Hbase, NiFi등 많은 어플리케이션에서 사용중이다.<br/>
주키퍼는 분산 어플리케이션을 위한 코디네이션 시스템으로 분산되어 있는 각 어플리케이션의 정보를 중앙에 집중하고 구성 관리, 그룹 관리 네이밍, 동기화 등의 서비스를 제공한다.<br/>
하둡에서 주키퍼는 노드들의 상태를 관리하고 Active 네임노드가 죽으면 Stanby 네임노드를 Active로 바꿔주는 HA 구성에도 필요하다. <br/>
<center> <img src="{{site.url}}/img/posts/kafka_2/zookeeper_architecture.jpeg" width="600" height="400"> </center>
<center> 주키퍼 서비스 (출처:https://zookeeper.apache.org/doc/r3.7.0/zookeeperOver.html) </center><br/>

위의 그림처럼 주키퍼는 서버 여러대를 클러스터로 구성하고 분산 어플리케이션들이 각각 클라이언트가 되어 주키퍼 서버들과 커넥션을 맺어 상태 정보등을 주고 받는다.
이때 상태 정보들은 주키퍼의 znode에 키 밸류 형태로 저장되고 znode에 키값이 저장된것을 이용하여 분산 어플리케이션들이 서로의 데이터를 주고 받게 된다.
주키퍼에서 사용되는 znode는 데이터를 저장하기 위한 공간으로 일반 컴퓨터의 파일이나 폴더 개념이라고 생각하면 된다.<br/>
일반적으로 znode에 저장되는 데이터 크기는 바이트에서 킬로바이트로 매우 작지만 모든 데이터는 메모리에 저장하기 떄문에 jvm의 heap memory를 모든 znode를 올릴 수 있는 충분한 크기로 만들어야 한다. <br/>
또한 아래 그림 처럼 디렉토리와 비슷한 구조로 자식노드를 가지고있는 계층형 구조로 되어있다.<br/>

<center> <img src="{{site.url}}/img/posts/kafka_2/zknamespace.jpeg" width="600" height="400"> </center>
<center>주키퍼 네임 스페이스 구조 (출처:https://zookeeper.apache.org/doc/r3.7.0/zookeeperOver.html)</center><br/>

주키퍼의 지노드는 데이터 변경 등에 대한 유효성 검사를 위해 버전 번호를 관리하며 데이터가 변경될 때마다 지노드의 버전 번호가 증가하게 된다.
앙상블(클러스터)로 구성되어 있는 주키퍼는 노드가 과반수 이상 유지된다면 지속적인 서비스가 가능하다.
이 내용을 보면 주키퍼는 홀수로 구성하는게 효율이 좋을것으로 예상된다.<br/>
또한 아래 그래프를 보면 노드수에 비해 꾀나 선형적으로 데이터 처리량이 증가하는것을 보인다.<br/>

<center> <img src="{{site.url}}/img/posts/kafka_2/zkperfRW-3.2.jpg" width="600" height="400"> </center>

<center>주키퍼 서버당 처리량 (출처:https://zookeeper.apache.org/doc/r3.7.0/zookeeperOver.html)</center><br/>

## 2. 주키퍼 설치
나는 VM을 새로 만들기보다 Docker에 centos 7.4 기본 이미지가 있기 때문에 my-net이라는 네트워크를 만들고 khg-zk001~khg-zk003 컨테이너를 만들어 설치를 하려고한다.
아래 처럼 --privileged 옵션과 /sbin/init으로 실행시킨 후 docker exec -it {컨테이너명} /bin/bash로 들어가야 systemd reload가 가능하다.
<br/>

<center>주키퍼 컨테이너 생성.</center>
```
1번서버 : docker run --privileged -dit -h khg-zk001 --network my-net --name khg-zk001 -v $PWD/zk003/opt:/opt -v $PWD/zk001/data:/data centos7-base:7.4 /sbin/init
2번서버 : docker run --privileged -dit -h khg-zk002 --network my-net --name khg-zk002 -v $PWD/zk003/opt:/opt -v $PWD/zk002/data:/data centos7-base:7.4 /sbin/init
3번서버 : docker run --privileged -dit -h khg-zk003 --network my-net --name khg-zk003 -v $PWD/zk003/opt:/opt -v $PWD/zk003/data:/data centos7-base:7.4 /sbin/init
```

<center>네트워크 할당 확인.</center>
<center><img src="{{site.url}}/img/posts/kafka_2/zoo2.png" width="600" height="400"> </center>

<center> ping으로 호스트명으로 서버를 찾는지 확인. </center>
<center> <img src="{{site.url}}/img/posts/kafka_2/zoo3.png" width="600" height="400"> </center>

책에서는 사전 준비로 openjdk를 설치하기 떄문에 각 컨테이너에서 아래 명령어로 openjdk를 설치했다.

```
yum -y install java-1.8.0-openjdk
```

#### 2.1 주키퍼 다운로드
책은 2018년에 출간되어서 그런지 주키퍼 3.4.10 버전을 설치했다.
현재는 3.7.0 버전까지 릴리즈되었지만 원활한 실습 진행을 위해 책과같은 3.4.10 버전을 설치하도록 하겠다.
컨테이너에는 wget도 설치되어있지 않아 아래 명령어로 설치하였다.

```
yum -y install wget
```

아래 명령어로 주키퍼 다운로드 (현재 공식홈페이지 링크는 책이랑 링크가 좀다르다.)
```
wget https://archive.apache.org/dist/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.tar.gz
```
아래 명령어로 압축 해제
```
tar zxf zookeeper-3.4.10.tar.gz
```
아래 명령어로 zookeeper-3.4.10 디렉토리에 zookeeper라는 이름의 심볼릭 링크 설정

```
ln -s zookeeper-3.4.10 zookeeper
```

주키퍼는 어플리케이션에서 별도의 데이터 디렉토리를 사용하는데 이 디렉토리에는 앞서 2장에서 말한 znode의 복사본인 스냅샷과 트랜잭션 로그들이 저장되며 지노드에 변경사항이 발생되면 이 data 디렉토리에 트랜잭션 로그에 변경사항이 추가된다.<br/>
이 로그가 어느정도 커지면 현재 모든 노드의 스냅샷이 파일 시스템에 저장되는데 이 스냅샷은 이전의 로그들을 대체하게된다.<br/>
한마디로 data디렉토리에 모든 로그가 저장되고 저장된 로그가 커지면 해당 시점에 스냅샷이 저장되는 디렉토리로 zookeeper가 분산 코디네이션을 수행하는데 중요한 디렉토리이다.</br>
나는 책과 같이 /data 경로에 디렉토리를 생성했다.
<center> <img src="{{site.url}}/img/posts/kafka_2/zoo4.png" width="600" height="400"> </center>
</br>
다음 단계로 앙상블(클러스터) 내 주키퍼 노드를 구분하기 위해 ID를 만들어야하는데 이를 주키퍼에서는 myid라고 부르며 정수 형태로 만들어주면 된다.
```
echo 1 > /data/myid
```
다른 서버에도 아이디를 2,3으로 생성한다.

다음으로는 주키퍼 환결성정을 만들어야하는데 나는 주키퍼를 /opt 디렉토리 밑에 압축을 풀었기 때문에 아래 명령어로 zoo.cfg 파일을 생성한다.
```
vi /opt/zookeeper/conf/zoo.cfg
```
책에서는 아래의 환경설정을 작성하라고 나와있는데 conf디렉토리에 zoo_sample.cfg라는 파일이있어 복사 붙혀넣기하면 빠르게 작성할수 있다.
<pre><code>
# The number of milliseconds of each tick
# 주키퍼가 사용하는 시간에 대한 기본 측정 단위(밀리초)
tickTime=2000

# The number of ticks that the initial
# synchronization phase can take : 팔로워가 리더와 초기에 연결하는 시간에 대한 타임 아웃 tick의 수
# 이 설정에서는 기본 tickTime이 2000밀리세컨드이기 때문에 20000밀리세컨드 안에는 연결을해야 타임아웃이 안나게 된다.
initLimit=10

# The number of ticks that can pass between
# sending a request and getting an acknowledgement
# 팔러워가 리더와 동기화 하는 시간에 대한 타임 아웃 tick의 수(주키퍼의 데이터가 크면 늘려야한다.)
# 이 설정에서는 5*2000(tickTime)안에 동기화를 못하면 앙상블에서 해당 서버는 제외가 된다.
syncLimit=5

# the directory where the snapshot is stored.
# 트랜잭션 로그와 스냅샷이 저장되는 경로
dataDir=/data
# the port at which the clients will connect
# 주키퍼 사용 TCP 포트
clientPort=2181
# server.{myid} 형식으로 주키퍼 앙상블을 구성하기 위한 서버의 정보를 설정.
# 2388,3888은 기본 설정으로 앙상블 노드간 연결하는데 사용되며 리더 선출에 사용된다.
server.1=khg-zk001:2888:3888
server.2=khg-zk002:2888:3888
server.3=khg-zk003:2888:3888
</code></pre>

#### 2.2.2 주키퍼 실행

아래의 명령어로 주키퍼 실행과 종료가 가능하다.

```
주키퍼 실행 : /opt/zookeeper/bin/zkServer.sh start
주키퍼 종료 : /opt/zookeeper/bin/zkServer.sh stop
```

이제 다음으로는 systemed에 주키퍼 프로세스를 등록시킬건데 여기서 systemed란 부팅 중 시작하는 서비스, 데몬들을 관리하는 시스템으로 여기에 추가하게 되면 서버 부팅시 바로 주키퍼를 실행시킬 수 있다.
systemed에 등록하기 위해서는 주키퍼용 systemed라는 파일을 만드는데 이 책에서는 zookeeper-server.service라는 명칭으로 만든다.

```
vi /etc/systemd/system/zookeeper-server.service
```

zookeeper-server.service 파일에 아래와 같이 작성한다.
책과는 설치경로가 다른것 외에는 동일하다.
<pre><code>
# Unit은 일반적인 옵션을 나타내며 가장 많이 사용되는 옵션은 After 또는 Before인데 옵션명 그대로 부팅시 시작되는 어떤 유닛이 시작되기 전이나 시작후에 해당 서비스를 실행시키겠다는 내용이다.
# 유닛의 종류는 https://haker.tistory.com/51에 잘정리가 되어있으니 나중에 한번 보는것도 좋겠다.
[Unit]
Description=zookeeper-server
After=network.target
# Service옵션은 서비스 실행과 관련된 옵션으로 책에 아래와 같이 정리가 되어있다.
# Type : ExecStart에 영향을 주는 유닛 프로세스가 시작되며 simple, forking, oneshot, idle가 있다.
# SyslogIdentifier : syslog에서 구분하기 위한 이름.
# WorkingDirectory : 실행된 프로세스의 작업 디렉토리를 의미하며 만약 설정하지 않으면 사용자 계정의 홈으로 지정됨.
# Restart : 이 옵션을 always로 설정하면 systemctl 명령어로 중지한 경우를 제외하고는 항상 프로세스가 종료된 뒤 재시작.
# RestartSec : 이 옵션은 Restart옵션과 연결되어 몇 초에 실행할지를 결정.
# ExecStart,ExecStop : 서비스가 실행, 정지될 때 실행할 명령어 또는 스크립트 설정.
[Service]
Type=forking
User=root
Group=root
SyslogIdentifier=zookeeper-server
WorkingDirectory=/opt/zookeeper
Restart=always
RestartSec=0s
ExecStart=/opt/zookeeper/bin/zkServer.sh start
ExecStop=/opt/zookeeper/bin/zkServer.sh stop
</code></pre>


systemed의 파일을 새로 만들거나 기존 파일을 수정한 이후에는 반드시 systemd 재시작을 위해 아래 명령어를 실행해야한다.

```
systemctl daemon-reload
```

다음으로는 주키퍼 서비스가 서버가 부팅될 때 자동으로 실행될 수 있도록 허용한다.

```
systemctl enable zookeeper-server.service
```

아래의 명령어로 주키퍼 서버 상태 확인.

```
systemctl status zookeeper-server.service
```
<p align="center"><img src="{{site.url}}/img/posts/kafka_2/zoo5.png" width="900" height="110"></p>

- 첫번째 줄의 zookeeper-server.service - zookeeper-server 는 systemd 옵션 중 Description으로 정의했던 부분이 출력.

- 두번째 줄의 Loaded: loaded (/etc/systemd/system/zookeeper-server.service; static; vendor preset: disabled) 은 해당 설정이 OS 메모리 영역에 로드 되었는지 확인할수 있는 부분으로 자동 시작으로 되어있으면  enable 이다.

- Active: active (running)로 시작하는 세번째 줄은 해당 서비스가 잘 실행되고있는지 확인할 수 잇으며 실행된지 얼마나 지났는지도 알수있다.

- Process 부분은 주키퍼 프로세스 관련 부분과 실행시 옵션 부분을 확인 할 수 있다.

- 날짜로 시작하는 영역은 주키퍼 관련 로그를 볼 수 있다.
